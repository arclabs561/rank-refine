--- src/colbert.rs
+++ replace <= with > in pool_tokens_adaptive
@@ -312,17 +312,17 @@
 /// assert_eq!(pooled_2.len(), 2);
 ///
 /// // Factor 4: uses sequential (speed matters more at aggressive compression)
 /// let pooled_4 = colbert::pool_tokens_adaptive(&tokens, 4);
 /// assert_eq!(pooled_4.len(), 1);
 /// ```
 #[must_use]
 pub fn pool_tokens_adaptive(tokens: &[Vec<f32>], pool_factor: usize) -> Vec<Vec<f32>> {
-    if tokens.is_empty() || pool_factor <= 1 {
+    if tokens.is_empty() || pool_factor > /* ~ changed by cargo-mutants ~ */ 1 {
         return tokens.to_vec();
     }
 
     // For aggressive pooling (factor 4+), sequential is nearly as good and much faster
     // For moderate pooling (factor 2-3), clustering preserves quality better
     if pool_factor >= 4 {
         pool_tokens_sequential(tokens, pool_factor)
     } else {
