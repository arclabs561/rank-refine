--- src/colbert.rs
+++ replace pool_tokens_with_protected -> Vec<Vec<f32>> with vec![]
@@ -269,27 +269,17 @@
 ///
 /// Protected tokens are preserved unchanged and not included in clustering.
 #[must_use]
 pub fn pool_tokens_with_protected(
     tokens: &[Vec<f32>],
     pool_factor: usize,
     protected_count: usize,
 ) -> Vec<Vec<f32>> {
-    if tokens.is_empty() || pool_factor <= 1 {
-        return tokens.to_vec();
-    }
-
-    let protected_count = protected_count.min(tokens.len());
-    let protected = &tokens[..protected_count];
-    let poolable = &tokens[protected_count..];
-
-    let mut result = protected.to_vec();
-    result.extend(pool_tokens(poolable, pool_factor));
-    result
+    vec![] /* ~ changed by cargo-mutants ~ */
 }
 
 /// Adaptively choose the best pooling strategy based on pool factor.
 ///
 /// - **Factor 1-3**: Uses clustering-based pooling (greedy or hierarchical)
 /// - **Factor 4+**: Uses sequential pooling (faster, nearly as good for aggressive compression)
 ///
 /// This is a convenience function that picks reasonable defaults. For full control,
