--- src/colbert.rs
+++ replace pool_tokens -> Vec<Vec<f32>> with vec![]
@@ -73,36 +73,17 @@
 /// - **With `hierarchical` feature**: Ward's method via kodama (O(n² log n), better quality)
 ///
 /// # Arguments
 ///
 /// * `tokens` - Document token embeddings (assumed L2-normalized for `ColBERT`)
 /// * `pool_factor` - Target compression ratio (2 = 50% reduction, 3 = 66%, etc.)
 #[must_use]
 pub fn pool_tokens(tokens: &[Vec<f32>], pool_factor: usize) -> Vec<Vec<f32>> {
-    if tokens.is_empty() || pool_factor <= 1 {
-        return tokens.to_vec();
-    }
-
-    let n = tokens.len();
-    let target_count = (n / pool_factor).max(1);
-
-    if n <= target_count {
-        return tokens.to_vec();
-    }
-
-    #[cfg(feature = "hierarchical")]
-    {
-        pool_tokens_hierarchical(tokens, target_count)
-    }
-
-    #[cfg(not(feature = "hierarchical"))]
-    {
-        pool_tokens_greedy(tokens, target_count)
-    }
+    vec![] /* ~ changed by cargo-mutants ~ */
 }
 
 /// Greedy agglomerative clustering (default, O(n³)).
 #[cfg(not(feature = "hierarchical"))]
 fn pool_tokens_greedy(tokens: &[Vec<f32>], target_count: usize) -> Vec<Vec<f32>> {
     let n = tokens.len();
     let mut clusters: Vec<Vec<usize>> = (0..n).map(|i| vec![i]).collect();
 
