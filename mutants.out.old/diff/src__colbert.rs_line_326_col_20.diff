--- src/colbert.rs
+++ replace >= with < in pool_tokens_adaptive
@@ -318,17 +318,17 @@
 #[must_use]
 pub fn pool_tokens_adaptive(tokens: &[Vec<f32>], pool_factor: usize) -> Vec<Vec<f32>> {
     if tokens.is_empty() || pool_factor <= 1 {
         return tokens.to_vec();
     }
 
     // For aggressive pooling (factor 4+), sequential is nearly as good and much faster
     // For moderate pooling (factor 2-3), clustering preserves quality better
-    if pool_factor >= 4 {
+    if pool_factor < /* ~ changed by cargo-mutants ~ */ 4 {
         pool_tokens_sequential(tokens, pool_factor)
     } else {
         pool_tokens(tokens, pool_factor)
     }
 }
 
 #[cfg(not(feature = "hierarchical"))]
 fn cluster_similarity(tokens: &[Vec<f32>], c1: &[usize], c2: &[usize]) -> f32 {
