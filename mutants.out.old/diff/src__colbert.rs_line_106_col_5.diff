--- src/colbert.rs
+++ replace pool_tokens_greedy -> Vec<Vec<f32>> with vec![vec![-1.0]]
@@ -98,43 +98,17 @@
     {
         pool_tokens_greedy(tokens, target_count)
     }
 }
 
 /// Greedy agglomerative clustering (default, O(n³)).
 #[cfg(not(feature = "hierarchical"))]
 fn pool_tokens_greedy(tokens: &[Vec<f32>], target_count: usize) -> Vec<Vec<f32>> {
-    let n = tokens.len();
-    let mut clusters: Vec<Vec<usize>> = (0..n).map(|i| vec![i]).collect();
-
-    while clusters.len() > target_count {
-        let mut best_i = 0;
-        let mut best_j = 1;
-        let mut best_sim = f32::NEG_INFINITY;
-
-        for i in 0..clusters.len() {
-            for j in (i + 1)..clusters.len() {
-                let sim = cluster_similarity(tokens, &clusters[i], &clusters[j]);
-                if sim > best_sim {
-                    best_sim = sim;
-                    best_i = i;
-                    best_j = j;
-                }
-            }
-        }
-
-        let merged = clusters.remove(best_j);
-        clusters[best_i].extend(merged);
-    }
-
-    clusters
-        .iter()
-        .map(|indices| mean_pool(tokens, indices))
-        .collect()
+    vec![vec![-1.0]] /* ~ changed by cargo-mutants ~ */
 }
 
 /// Ward's method hierarchical clustering via kodama (O(n² log n), better quality).
 ///
 /// Ward's method minimizes within-cluster variance at each merge step,
 /// producing more semantically coherent clusters than greedy approaches.
 ///
 /// # Panics
