--- src/crossencoder.rs
+++ replace refine -> Vec<(I, Score)> with vec![]
@@ -61,44 +61,17 @@
 /// CE scores normalized to \[0,1\]. `alpha`: 0 = all CE, 1 = all original.
 #[must_use]
 pub fn refine<I: Clone, M: CrossEncoderModel>(
     model: &M,
     query: &str,
     candidates: &[(I, &str, f32)], // (id, text, original_score)
     alpha: f32,
 ) -> Vec<(I, Score)> {
-    if candidates.is_empty() {
-        return Vec::new();
-    }
-
-    let docs: Vec<&str> = candidates.iter().map(|(_, text, _)| *text).collect();
-    let ce_scores = model.score_batch(query, &docs);
-
-    // Normalize CE scores to [0, 1]
-    let (min_ce, max_ce) = ce_scores
-        .iter()
-        .fold((f32::INFINITY, f32::NEG_INFINITY), |(lo, hi), &s| {
-            (lo.min(s), hi.max(s))
-        });
-    let range = (max_ce - min_ce).max(1e-9);
-
-    let mut results: Vec<(I, Score)> = candidates
-        .iter()
-        .zip(ce_scores)
-        .map(|((id, _, orig), ce)| {
-            let ce_norm = (ce - min_ce) / range;
-            // Use mul_add for better precision
-            let blended = (1.0 - alpha).mul_add(ce_norm, alpha * orig);
-            (id.clone(), blended)
-        })
-        .collect();
-
-    crate::sort_scored_desc(&mut results);
-    results
+    vec![] /* ~ changed by cargo-mutants ~ */
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
 
     struct MockEncoder;
 
