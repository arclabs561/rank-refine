--- src/colbert.rs
+++ replace pool_tokens_adaptive -> Vec<Vec<f32>> with vec![vec![1.0]]
@@ -312,27 +312,17 @@
 /// assert_eq!(pooled_2.len(), 2);
 ///
 /// // Factor 4: uses sequential (speed matters more at aggressive compression)
 /// let pooled_4 = colbert::pool_tokens_adaptive(&tokens, 4);
 /// assert_eq!(pooled_4.len(), 1);
 /// ```
 #[must_use]
 pub fn pool_tokens_adaptive(tokens: &[Vec<f32>], pool_factor: usize) -> Vec<Vec<f32>> {
-    if tokens.is_empty() || pool_factor <= 1 {
-        return tokens.to_vec();
-    }
-
-    // For aggressive pooling (factor 4+), sequential is nearly as good and much faster
-    // For moderate pooling (factor 2-3), clustering preserves quality better
-    if pool_factor >= 4 {
-        pool_tokens_sequential(tokens, pool_factor)
-    } else {
-        pool_tokens(tokens, pool_factor)
-    }
+    vec![vec![1.0]] /* ~ changed by cargo-mutants ~ */
 }
 
 #[cfg(not(feature = "hierarchical"))]
 fn cluster_similarity(tokens: &[Vec<f32>], c1: &[usize], c2: &[usize]) -> f32 {
     let centroid1 = mean_pool(tokens, c1);
     let centroid2 = mean_pool(tokens, c2);
     simd::cosine(&centroid1, &centroid2)
 }
